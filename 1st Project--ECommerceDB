CREATE DATABASE ECommerceDB;
USE ECommerceDB;

-- Create the Categories table
CREATE TABLE Categories (
    category_id INT PRIMARY KEY AUTO_INCREMENT,
    category_name VARCHAR(255) NOT NULL
);

-- Create the Products table
CREATE TABLE Products (
    product_id INT PRIMARY KEY AUTO_INCREMENT,
    product_name VARCHAR(255) NOT NULL,
    category_id INT,
    price DECIMAL(10, 2) NOT NULL,
    stock_quantity INT,
    FOREIGN KEY (category_id) REFERENCES Categories(category_id)
);

-- Create the Customers table
CREATE TABLE Customers (
    customer_id INT PRIMARY KEY AUTO_INCREMENT,
    first_name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    registration_date DATE
);

-- Create the Orders table
CREATE TABLE Orders (
    order_id INT PRIMARY KEY AUTO_INCREMENT,
    customer_id INT,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES Customers(customer_id)
);

-- Create the Order_Items table
CREATE TABLE Order_Items (
    order_item_id INT PRIMARY KEY AUTO_INCREMENT,
    order_id INT,
    product_id INT,
    quantity INT NOT NULL,
    price_per_item DECIMAL(10, 2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES Orders(order_id),
    FOREIGN KEY (product_id) REFERENCES Products(product_id)
);
show tables;
-- Insert data into Categories
INSERT INTO Categories (category_name) VALUES
('Electronics'),
('Books'),
('Clothing'),
('Home & Kitchen');

-- Insert data into Products
INSERT INTO Products (product_name, category_id, price, stock_quantity) VALUES
('Laptop', 1, 1200.00, 50),
('Smartphone', 1, 800.00, 150),
('The Great Gatsby', 2, 10.00, 200),
('To Kill a Mockingbird', 2, 12.00, 180),
('T-Shirt', 3, 25.00, 300),
('Jeans', 3, 50.00, 250),
('Coffee Maker', 4, 60.00, 100),
('Blender', 4, 45.00, 120);

-- Insert data into Customers
INSERT INTO Customers (first_name, last_name, email, registration_date) VALUES
('John', 'Doe', 'john.doe@example.com', '2023-01-15'),
('Jane', 'Smith', 'jane.smith@example.com', '2023-02-20'),
('Alice', 'Johnson', 'alice.j@example.com', '2023-03-10'),
('Bob', 'Brown', 'bob.b@example.com', '2023-04-05');

-- Insert data into Orders
INSERT INTO Orders (customer_id, order_date, total_amount) VALUES
(1, '2023-02-10', 1210.00),
(2, '2023-03-15', 825.00),
(1, '2023-04-20', 75.00),
(3, '2023-05-01', 10.00),
(4, '2023-05-05', 90.00),
(2, '2023-05-12', 12.00);

-- Insert data into Order_Items
INSERT INTO Order_Items (order_id, product_id, quantity, price_per_item) VALUES
(1, 2, 1, 1200.00),
(1, 3, 1, 10.00),
(2, 2, 1, 800.00),
(2, 5, 1, 25.00),
(3, 6, 1, 50.00),
(3, 5, 1, 25.00),
(4, 3, 1, 10.00),
(5, 7, 1, 60.00),
(5, 8, 1, 45.00),
(6, 4, 1, 12.00);
show tables;
#Till now we have sucessfully learn how to create table and database
#Now We will do how to retrive the data .
Basic Retrieval Queries
1. Retrieve all information about all products.
code
SQL
SELECT * FROM Products;
2. List the names and prices of all products.
code
SQL
SELECT product_name, price FROM Products;
3. Find all customers who registered on or after January 1, 2023.
code
SQL
SELECT * FROM Customers WHERE registration_date >= '2023-01-01';
4. Get the first name, last name, and email of all customers.
code
SQL
SELECT first_name, last_name, email FROM Customers;
5. Find all products with a stock quantity of less than 20.
code
SQL
SELECT * FROM Products WHERE stock_quantity < 20;
6. Retrieve all orders with a total amount greater than $500.
code
SQL
SELECT * FROM Orders WHERE total_amount > 500;
7. List all products, ordered by price from lowest to highest.
code
SQL
SELECT * FROM Products ORDER BY price ASC;
8. List all products, ordered by price from highest to lowest.
code
SQL
SELECT * FROM Products ORDER BY price DESC;
9. Find the top 10 most expensive products.
code
SQL
SELECT * FROM Products ORDER BY price DESC LIMIT 10;
10. Find all customers whose last name starts with 'S'.
code
SQL
SELECT * FROM Customers WHERE last_name LIKE 'S%';
Aggregate Queries
11. Count the total number of customers.
code
SQL
SELECT COUNT(*) FROM Customers;
12. Find the total stock quantity of all products.
code
SQL
SELECT SUM(stock_quantity) FROM Products;
13. Calculate the average price of all products.
code
SQL
SELECT AVG(price) FROM Products;
14. Find the highest price among all products.
code
SQL
SELECT MAX(price) FROM Products;
15. Find the lowest price among all products.
code
SQL
SELECT MIN(price) FROM Products;
16. Count the number of orders placed by each customer.
code
SQL
SELECT customer_id, COUNT(order_id) AS number_of_orders
FROM Orders
GROUP BY customer_id;
17. Find the total amount spent by each customer.
code
SQL
SELECT customer_id, SUM(total_amount) AS total_spent
FROM Orders
GROUP BY customer_id;
18. Find the categories with more than 5 products.
code
SQL
SELECT category_id, COUNT(product_id) AS number_of_products
FROM Products
GROUP BY category_id
HAVING COUNT(product_id) > 5;
19. Calculate the total quantity of each product sold.
code
SQL
SELECT product_id, SUM(quantity) AS total_quantity_sold
FROM Order_Items
GROUP BY product_id;
20. Find the customers who have placed more than 3 orders.
code
SQL
SELECT customer_id, COUNT(order_id)
FROM Orders
GROUP BY customer_id
HAVING COUNT(order_id) > 3;
JOIN Queries
21. Retrieve the names of customers who have placed orders.
code
SQL
SELECT DISTINCT c.first_name, c.last_name
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id;
22. List all orders with the customer's first name, last name, and order date.
code
SQL
SELECT o.order_id, c.first_name, c.last_name, o.order_date
FROM Orders o
JOIN Customers c ON o.customer_id = c.customer_id;
23. Find the products that have been ordered, along with the quantity.```sql
SELECT p.product_name, oi.quantity
FROM Products p
JOIN Order_Items oi ON p.product_id = oi.product_id;
code
Code
**24. Get the details of each order item, including the product name and price per item.**
```sql
SELECT o.order_id, p.product_name, oi.quantity, oi.price_per_item
FROM Orders o
JOIN Order_Items oi ON o.order_id = oi.order_id
JOIN Products p ON oi.product_id = p.product_id;
25. List all products and the total revenue they have generated.
code
SQL
SELECT p.product_name, SUM(oi.quantity * oi.price_per_item) AS total_revenue
FROM Products p
JOIN Order_Items oi ON p.product_id = oi.product_id
GROUP BY p.product_name
ORDER BY total_revenue DESC;
26. Find all customers who have not placed any orders.
code
SQL
SELECT c.customer_id, c.first_name, c.last_name
FROM Customers c
LEFT JOIN Orders o ON c.customer_id = o.customer_id
WHERE o.order_id IS NULL;
27. Find all products that have never been ordered.
code
SQL
SELECT p.product_id, p.product_name
FROM Products p
LEFT JOIN Order_Items oi ON p.product_id = oi.product_id
WHERE oi.order_item_id IS NULL;
28. Retrieve the top 5 customers who have spent the most.
code
SQL
SELECT c.customer_id, c.first_name, c.last_name, SUM(o.total_amount) AS total_spent
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY total_spent DESC
LIMIT 5;
29. List all orders from a specific customer (e.g., customer_id = 1).
code
SQL
SELECT o.order_id, o.order_date, o.total_amount
FROM Orders o
JOIN Customers c ON o.customer_id = c.customer_id
WHERE c.customer_id = 1;
30. Find the total number of items in each order.
code
SQL
SELECT order_id, SUM(quantity) AS total_items
FROM Order_Items
GROUP BY order_id;
Subquery Queries
31. Find customers who have placed an order with a total amount greater than the average total amount of all orders.
code
SQL
SELECT *
FROM Customers
WHERE customer_id IN (
    SELECT customer_id
    FROM Orders
    WHERE total_amount > (SELECT AVG(total_amount) FROM Orders)
);
32. Retrieve the products that have been ordered by a specific customer (e.g., customer_id = 1).
code
SQL
SELECT *
FROM Products
WHERE product_id IN (
    SELECT product_id
    FROM Order_Items
    WHERE order_id IN (
        SELECT order_id
        FROM Orders
        WHERE customer_id = 1
    )
);
33. Find the products that are more expensive than the average price of all products.
code
SQL
SELECT *
FROM Products
WHERE price > (SELECT AVG(price) FROM Products);
34. Find the customer who has placed the most recent order.
code
SQL
SELECT *
FROM Customers
WHERE customer_id = (
    SELECT customer_id
    FROM Orders
    ORDER BY order_date DESC
    LIMIT 1
);
35. List the orders that contain a product with a price greater than $200.
code
SQL
SELECT *
FROM Orders
WHERE order_id IN (
    SELECT order_id
    FROM Order_Items
    WHERE product_id IN (
        SELECT product_id
        FROM Products
        WHERE price > 200
    )
);
36. Find the total number of orders for each customer using a subquery.
code
SQL
SELECT c.first_name, c.last_name,
       (SELECT COUNT(*) FROM Orders o WHERE o.customer_id = c.customer_id) AS order_count
FROM Customers c;
37. Retrieve the order with the highest total amount.
code
SQL
SELECT *
FROM Orders
WHERE total_amount = (SELECT MAX(total_amount) FROM Orders);```

**38. Find customers who registered before the first order was placed.**
```sql
SELECT *
FROM Customers
WHERE registration_date < (SELECT MIN(order_date) FROM Orders);
39. Find the average order amount for customers who have placed more than one order.
code
SQL
SELECT AVG(total_amount)
FROM Orders
WHERE customer_id IN (
    SELECT customer_id
    FROM Orders
    GROUP BY customer_id
    HAVING COUNT(order_id) > 1
);
40. Find the products that have been sold more than the average quantity per product.
code
SQL
SELECT p.product_name
FROM Products p
JOIN (
    SELECT product_id, SUM(quantity) as total_quantity
    FROM Order_Items
    GROUP BY product_id
) AS sold_quantities ON p.product_id = sold_quantities.product_id
WHERE sold_quantities.total_quantity > (
    SELECT AVG(total_quantity)
    FROM (
        SELECT SUM(quantity) as total_quantity
        FROM Order_Items
        GROUP BY product_id
    ) AS avg_quantities
);
Advanced and Miscellaneous Queries
41. Find the month with the highest total sales.
code
SQL
SELECT STRFTIME('%Y-%m', order_date) as sales_month, SUM(total_amount) as monthly_sales
FROM Orders
GROUP BY sales_month
ORDER BY monthly_sales DESC
LIMIT 1;
-- Note: The date function might vary depending on the specific SQL dialect (e.g., DATE_FORMAT for MySQL).
42. Rank customers based on their total spending.
code
SQL
SELECT c.first_name, c.last_name, SUM(o.total_amount) as total_spent,
       RANK() OVER (ORDER BY SUM(o.total_amount) DESC) as spending_rank
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id;
43. Find the running total of sales over time.
code
SQL
SELECT order_date, total_amount,
       SUM(total_amount) OVER (ORDER BY order_date) as running_total
FROM Orders;
44. Find the first order date for each customer.
code
SQL
SELECT c.first_name, c.last_name, MIN(o.order_date) as first_order_date
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id;
45. Categorize products into 'Expensive' and 'Affordable' based on a price threshold (e.g., $100).
code
SQL
SELECT product_name, price,
       CASE
           WHEN price > 100 THEN 'Expensive'
           ELSE 'Affordable'
       END as price_category
FROM Products;
46. Find the percentage of total revenue contributed by each product.
code
SQL
SELECT p.product_name,
       (SUM(oi.quantity * oi.price_per_item) / (SELECT SUM(total_amount) FROM Orders)) * 100 as revenue_percentage
FROM Products p
JOIN Order_Items oi ON p.product_id = oi.product_id
JOIN Orders o ON oi.order_id = o.order_id
GROUP BY p.product_name
ORDER BY revenue_percentage DESC;
47. Find the time difference between a customer's registration and their first order.
code
SQL
SELECT c.customer_id, c.first_name, c.last_name,
       MIN(o.order_date) as first_order_date,
       c.registration_date,
       JULIANDAY(MIN(o.order_date)) - JULIANDAY(c.registration_date) as days_to_first_order
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id;
-- Note: The date difference function might vary (e.g., DATEDIFF for MySQL/SQL Server).
48. Find the best-selling product in each category.
code
SQL
WITH ProductSales AS (
    SELECT p.category_id, p.product_name, SUM(oi.quantity) as total_quantity_sold,
           ROW_NUMBER() OVER(PARTITION BY p.category_id ORDER BY SUM(oi.quantity) DESC) as rn
    FROM Products p
    JOIN Order_Items oi ON p.product_id = oi.product_id
    GROUP BY p.category_id, p.product_name
)
SELECT category_id, product_name, total_quantity_sold
FROM ProductSales
WHERE rn = 1;
49. Find customers who have ordered in consecutive months.
code
SQL
WITH MonthlyOrders AS (
    SELECT DISTINCT customer_id, STRFTIME('%Y-%m', order_date) as order_month
    FROM Orders
)
SELECT m1.customer_id
FROM MonthlyOrders m1
JOIN MonthlyOrders m2 ON m1.customer_id = m2.customer_id
WHERE STRFTIME('%Y-%m', DATE(m1.order_month || '-01', '+1 month')) = m2.order_month;
-- Note: Date manipulation functions are highly dependent on the SQL dialect.
50. Calculate the Customer Lifetime Value (total amount spent).
code
SQL
SELECT c.customer_id, c.first_name, c.last_name, SUM(o.total_amount) as lifetime_value
FROM Customers c
JOIN Orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id
ORDER BY lifetime_value DESC;


#Some more Important questions on Joints:
1. The "Grand Summary" (Multi-Table INNER JOIN)
This query joins all four main tables to get a complete, detailed summary for every single item within every order. It's a common query for generating detailed invoices or order reports.
Query:
code
SQL
SELECT
    c.first_name,
    c.last_name,
    o.order_id,
    o.order_date,
    p.product_name,
    cat.category_name,
    oi.quantity,
    oi.price_per_item,
    (oi.quantity * oi.price_per_item) AS item_total
FROM Customers AS c
JOIN Orders AS o ON c.customer_id = o.customer_id
JOIN Order_Items AS oi ON o.order_id = oi.order_id
JOIN Products AS p ON oi.product_id = p.product_id
JOIN Categories AS cat ON p.category_id = cat.category_id
ORDER BY
    o.order_date DESC,
    o.order_id,
    p.product_name;
Explanation:
We start with Customers and INNER JOIN Orders to link customers to their orders.
We then INNER JOIN Order_Items to see which products were in each order.
Finally, we INNER JOIN Products and Categories to get the product name and category name.
This query connects a piece of information from every table to give a complete picture of each transaction line.
2. Finding Unpopular Products (LEFT JOIN)
A LEFT JOIN is perfect for finding records in one table that don't have a corresponding match in another. This query finds all products that have never been sold. This is critical information for inventory management.
Query:
code
SQL
SELECT
    p.product_id,
    p.product_name,
    p.stock_quantity
FROM Products AS p
LEFT JOIN Order_Items AS oi ON p.product_id = oi.product_id
WHERE
    oi.order_item_id IS NULL;
Explanation:
LEFT JOIN selects all products from the Products table.
It then tries to match them with records in the Order_Items table.
If a product has never been ordered, the columns from Order_Items (like oi.order_item_id) will be NULL for that product.
The WHERE clause filters for only those rows where the match was not found, giving you the unsold products.
3. Categories Without Any Products (LEFT JOIN)
Similar to the above, you can find categories that are empty. This is useful for database cleanup and content management.
Query:
code
SQL
SELECT
    cat.category_id,
    cat.category_name
FROM Categories AS cat
LEFT JOIN Products AS p ON cat.category_id = p.category_id
WHERE
    p.product_id IS NULL;
Explanation:
This query takes all categories and tries to join them with products.
If a category has no products associated with it, the product-related columns will be NULL.
The WHERE clause isolates these empty categories.
4. Customer and Their Total Number of Orders (LEFT JOIN with Aggregation)
This query lists all customers, including those who have never placed an order, and shows their total order count.
Query:
code
SQL
SELECT
    c.customer_id,
    c.first_name,
    c.email,
    COUNT(o.order_id) AS total_orders
FROM Customers AS c
LEFT JOIN Orders AS o ON c.customer_id = o.customer_id
GROUP BY
    c.customer_id,
    c.first_name,
    c.email
ORDER BY
    total_orders DESC;
Explanation:
A LEFT JOIN ensures every customer is included in the result, regardless of whether they have an order.
COUNT(o.order_id) is used instead of COUNT(*) because it only counts non-NULL values. For customers with no orders, o.order_id will be NULL, so their count will correctly be 0.
GROUP BY collapses the rows for each customer to give a single summary row.
5. Best-Selling Product per Category (JOIN with a Subquery/CTE)
This advanced query identifies the product that has sold the highest quantity within each category. This is powerful for marketing and sales analysis.
Query (using a Common Table Expression - CTE):
code
SQL
WITH ProductSales AS (
    SELECT
        p.category_id,
        p.product_name,
        SUM(oi.quantity) AS total_quantity_sold
    FROM Products AS p
    JOIN Order_Items AS oi ON p.product_id = oi.product_id
    GROUP BY
        p.category_id, p.product_name
),
RankedSales AS (
    SELECT
        category_id,
        product_name,
        total_quantity_sold,
        RANK() OVER(PARTITION BY category_id ORDER BY total_quantity_sold DESC) AS sales_rank
    FROM ProductSales
)
SELECT
    cat.category_name,
    rs.product_name,
    rs.total_quantity_sold
FROM RankedSales AS rs
JOIN Categories AS cat ON rs.category_id = cat.category_id
WHERE
    rs.sales_rank = 1;
Explanation:
The ProductSales CTE first calculates the total quantity sold for each product.
The RankedSales CTE then uses a window function (RANK()) to assign a rank to each product within its category (PARTITION BY category_id) based on sales.
The final SELECT statement joins with the Categories table to get the category name and filters for only the products where the rank is 1 (the best-seller).
6. Finding Customers Who Bought a Specific Product (JOIN chain)
This query helps identify all customers who have purchased a particular product (e.g., 'Product XYZ'). This is great for targeted follow-up marketing.
Query:
code
SQL
SELECT DISTINCT
    c.customer_id,
    c.first_name,
    c.email
FROM Customers AS c
JOIN Orders AS o ON c.customer_id = o.customer_id
JOIN Order_Items AS oi ON o.order_id = oi.order_id
JOIN Products AS p ON oi.product_id = p.product_id
WHERE
    p.product_name = 'Product XYZ'; -- Replace with the actual product name
Explanation:
This query creates a direct path from Customers to Products.
It joins the tables in a chain: Customers -> Orders -> Order_Items -> Products.
The WHERE clause filters these results to only include transaction lines for the specific product.
SELECT DISTINCT ensures that if a customer bought the same product multiple times, they only appear once in the result.
7. Comparing a Product's Sale Price to its Current Price (JOIN with a Condition)
This query finds every instance where a product was sold at a price different from its current listed price in the Products table. This can help identify historical pricing data or data entry errors.
Query:
code
SQL
SELECT
    o.order_id,
    o.order_date,
    p.product_name,
    p.price AS current_list_price,
    oi.price_per_item AS actual_sale_price
FROM Order_Items AS oi
JOIN Products AS p ON oi.product_id = p.product_id
JOIN Orders AS o ON oi.order_id = o.order_id
WHERE
    p.price <> oi.price_per_item;
Explanation:
This query joins Order_Items with Products to bring the sale price and the current list price into the same row.
The WHERE clause directly compares these two values (<> means "not equal to") and returns only the rows where they differ.
8. CROSS JOIN for Potential Product Bundles
A CROSS JOIN creates a Cartesian product, meaning it pairs every row from the first table with every row from the second. While dangerous on large tables, it can be useful for creating potential combinations, for example, pairing every product from 'Category A' with every product from 'Category B' to brainstorm bundle ideas.
Query:
code
SQL
SELECT
    p1.product_name AS product_from_cat_A,
    p2.product_name AS product_from_cat_B
FROM Products AS p1
CROSS JOIN Products AS p2
WHERE
    p1.category_id = 1  -- Assuming Category A has id 1
    AND p2.category_id = 2 -- Assuming Category B has id 2
    AND p1.product_id <> p2.product_id;
Explanation:
This query pairs every product from category 1 with every product from category 2.
The WHERE clause is crucial for filtering the tables before the join to keep the result set manageable. The final condition p1.product_id <> p2.product_id ensures a product isn't bundled with itself.
9. Finding Customers Who Share a Registration Month (SELF JOIN)
A SELF JOIN is when you join a table to itself. It's used to compare rows within the same table. This query finds pairs of customers who registered in the same month and year.
Query:
code
SQL
SELECT
    c1.first_name || ' ' || c1.last_name AS customer_1,
    c2.first_name || ' ' || c2.last_name AS customer_2,
    strftime('%Y-%m', c1.registration_date) AS registration_month
FROM Customers AS c1
JOIN Customers AS c2
    ON strftime('%Y-%m', c1.registration_date) = strftime('%Y-%m', c2.registration_date)
    AND c1.customer_id < c2.customer_id;
(Note: || is for string concatenation in SQL standard/PostgreSQL/SQLite. Use CONCAT() for MySQL).
Explanation:
The Customers table is aliased twice (c1 and c2), effectively treating it as two separate tables.
The ON clause matches rows where the registration month is the same. The date function (strftime or DATE_FORMAT) is used to ignore the day.
The condition c1.customer_id < c2.customer_id is a critical trick to avoid duplicate pairs (e.g., showing 'John-Jane' and later 'Jane-John') and to prevent a customer from being paired with themselves.
10. FULL OUTER JOIN (Simulated)
A FULL OUTER JOIN returns all records when there is a match in either the left or the right table. It's essentially a combination of a LEFT and RIGHT join. MySQL doesn't support this syntax directly, but it can be simulated using UNION. This query will list all products and all order items, showing which products were never sold and which order items might have a missing product reference.
Query (for PostgreSQL, Oracle, etc.):
code
SQL
SELECT
    p.product_name,
    oi.order_id,
    oi.quantity
FROM Products p
FULL OUTER JOIN Order_Items oi ON p.product_id = oi.product_id;
Query (Simulated for MySQL):
code
SQL
-- LEFT JOIN part (finds all products and their sales)
SELECT p.product_name, oi.order_id, oi.quantity
FROM Products p
LEFT JOIN Order_Items oi ON p.product_id = oi.product_id
UNION
-- RIGHT JOIN part (finds all sales and their products)
SELECT p.product_name, oi.order_id, oi.quantity
FROM Products p
RIGHT JOIN Order_Items oi ON p.product_id = oi.product_id;
Explanation:
The first part of the UNION is a LEFT JOIN that gets all products, including those never ordered.
The second  part is a RIGHT JOIN that gets all order items, including any that might (due to bad data) reference a product that no longer exists.
UNION combines these two result sets and removes duplicate rows, effectively creating a FULL OUTER JOIN.












